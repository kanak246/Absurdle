// Absurdle allows users to play a game of absurdle:
// an adversarial game of wordle where the manager attempts to make the game
// as hard as possible by revealing as little information on each round as
// possible, changing the secret word in response to guesses as necessary.
/*
Name: Kanak Garg
TA: Andrew
Professor: Hunter and Miya
Class: CSE 122
Assignment: Absurdle
Date: 11/9/2022
*/

import java.util.*;
import java.io.*;

//Class Absurdle that imitates a "cheating" version of popular game
//wordle.
public class Absurdle  {
    public static final boolean DEBUG = false;

    // [[ ALL OF MAIN PROVIDED ]]
    public static void main(String[] args) throws FileNotFoundException {
        Scanner console = new Scanner(System.in);
        System.out.println("Welcome to the game of Absurdle.");

        System.out.print("What dictionary would you like to use? ");
        String dictName = console.next();

        System.out.print("What length word would you like to guess? ");
        int wordLength = console.nextInt();

        List<String> contents = loadFile(new Scanner(new File(dictName)));
        Set<String> words = pruneDictionary(contents, wordLength);

        if (DEBUG)
            System.out.println("words: " + words);

        List<String> guessedPatterns = new ArrayList<>();
        while (!isFinished(guessedPatterns)) {
            System.out.print("> ");
            String guess = console.next();
            String pattern = record(guess, words, wordLength);
            guessedPatterns.add(pattern);
            System.out.println(": " + pattern);
            System.out.println();
        }
        System.out.println("Absurdle " + guessedPatterns.size() + "/âˆž");
        System.out.println();
        printPatterns(guessedPatterns);
    }

    // [[ PROVIDED ]]
    public static void printPatterns(List<String> list) {
        for (String s : list) {
            System.out.println(s);
        }
    }

    // [[ PROVIDED ]]
    public static boolean isFinished(List<String> patterns) {
        if (patterns.isEmpty()) { // haven't guessed anything yet, so game isn't finished!
            return false;
        }
        String lastPattern = patterns.get(patterns.size() - 1); // get the pattern generated by the most recent guess
        return !lastPattern.contains("â¬œ") && !lastPattern.contains("ðŸŸ¨"); // must be all green to "win"
    }

    // [[ PROVIDED ]]
    public static List<String> loadFile(Scanner dictScan) {
        List<String> contents = new ArrayList<>();
        while (dictScan.hasNext()) {
            contents.add(dictScan.next());
        }

        return contents;
    }

    //Method takes in parameter of List <String> and int wordLength.
    //Method returns a Set<String>.
    //Method takes in contents of dictionary and uses the user's input for length of
    //words they want and returns a set of those unique length words that are present
    //in dictionary.
    //Method returns a IllegalArgumentException of user provided wordLength is less than
    //1 because it then "does not exist"
    public static Set<String> pruneDictionary(List<String> contents, int wordLength) {

        if (wordLength < 1) {
            throw new IllegalArgumentException();
        }

        Set <String> userWords = new TreeSet<String>();

        for (int i = 0; i < contents.size(); i++) {
            if (contents.get(i).length() == wordLength) {
                userWords.add(contents.get(i));
            }
        }
        return userWords;
    }

    //Method takes in parameter of String, Set<String> and int, and returns String pattern.
    //Using the given guess, the method determines next set of words (one with the most target words)
    // to be considered and returns the pattern associated with that set.
    //Method returns an IllegalArgumentException if guess length does not equal user specificed length
    //or the set is empty.
    public static String record(String guess, Set<String> words, int wordLength) {

        if (guess.length() != wordLength || words.isEmpty()) {
            throw new IllegalArgumentException();
        }

        Map <String, Set<String>> tracker = new TreeMap<String, Set<String>>();

        for (String targetWord : words) {

            String pattern = patternFor(targetWord, guess);
            if (!tracker.containsKey(pattern)) {
                tracker.put(pattern, new TreeSet<String>());
                tracker.get(pattern).add(targetWord);

            }
            else {
                tracker.get(pattern).add(targetWord);
            }
        }

        int max = 0;
        int count = 0;
        String input = "";
        for (String key: tracker.keySet()) {
            count = tracker.get(key).size();
            if (max < count) {
                max = count;
                input = key;
            }
        }
        words.clear();
        words.addAll(tracker.get(input));
        return input;
    }

    // Assumes that the given word is the same length as the given guess.
    // Returns a wordle pattern of blocks for the given guess, compared to the
    // given word.
    //Method tracks individual letters in word.
    //Method first finds the green and sets other values to temp x val.
    //Method then looks for yellow and grey matches.
    public static String patternFor(String word, String guess) {

        Map <Character, Integer> traverser = new HashMap<>();

        for (int i = 0; i < word.length(); i++) {
            char letter = word.charAt(i);
            if (traverser.containsKey(letter)) {
                traverser.put(letter, traverser.get(letter) + 1);
            }
            else {
                traverser.put(letter, 1);
            }
        }

        String userGuess = "";

        for (int i = 0; i < guess.length(); i++){
            if (word.charAt(i) == guess.charAt(i)){
                userGuess += "!";
                traverser.put(word.charAt(i), traverser.get(word.charAt(i)) - 1);
            } else {
                userGuess += "x";
            }
        }
        for (int i = 0; i < guess.length(); i++){
            char currentChar = guess.charAt(i);
            if (userGuess.charAt(i) == 'x'){
                if (traverser.containsKey(currentChar) && traverser.get(currentChar) > 0){
                    userGuess = userGuess.replaceFirst("x", "@");
                    traverser.put(currentChar, traverser.get(currentChar) - 1);
                } else {
                    userGuess = userGuess.replaceFirst("x", "%");
                }
            }
        }
        return replaceWithEmoji(userGuess);
    }

    //Method takes in paramter of String and returns String of emoji
    //Method replaces the characters with the corresponding emoji
    //that represent correct char and place, right char but not correct place, and
    //incorrect char.
    public static String replaceWithEmoji (String userGuess) {
        userGuess = userGuess.replace("!", "ðŸŸ©");
        userGuess = userGuess.replace("@", "ðŸŸ¨");
        userGuess = userGuess.replace("%", "â¬œ");

        return userGuess;
    }
}